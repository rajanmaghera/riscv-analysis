use std::rc::Rc;

use super::ParserNode;

/// This module contains a wrapper for the `ParserNode` enum that implements `PartialEq` and Eq
///
/// By default, equality is checked by comparing the id (generated by UUID) of two `ParserNodes`.
/// If we want to check if the data of two `ParserNodes` are equal, we can use this wrapper.
///
/// This is needed for testing as we want to check if the data of two `ParserNodes` are equal.
#[derive(Debug, Clone)]
pub struct ParserNodeDataWrapper(pub ParserNode);

impl PartialEq for ParserNodeDataWrapper {
    fn eq(&self, other: &Self) -> bool {
        match (&self.0, &other.0) {
            (ParserNode::FuncEntry(_), ParserNode::FuncEntry(_))
            | (ParserNode::FuncExit(_), ParserNode::FuncExit(_))
            | (ParserNode::ProgramEntry(_), ParserNode::ProgramEntry(_))
            | (ParserNode::ProgramExit(_), ParserNode::ProgramExit(_)) => true,
            (ParserNode::Arith(a), ParserNode::Arith(b)) => {
                a.inst == b.inst && a.rd == b.rd && a.rs1 == b.rs1 && a.rs2 == b.rs2
            }
            (ParserNode::IArith(a), ParserNode::IArith(b)) => {
                a.inst == b.inst && a.rd == b.rd && a.rs1 == b.rs1 && a.imm == b.imm
            }
            (ParserNode::Label(a), ParserNode::Label(b)) => a.name == b.name,
            (ParserNode::JumpLink(a), ParserNode::JumpLink(b)) => {
                a.inst == b.inst && a.name == b.name
            }
            (ParserNode::JumpLinkR(a), ParserNode::JumpLinkR(b)) => {
                a.inst == b.inst && a.rd == b.rd && a.rs1 == b.rs1 && a.imm == b.imm
            }
            (ParserNode::Basic(a), ParserNode::Basic(b)) => a.inst == b.inst,
            (ParserNode::Directive(a), ParserNode::Directive(b)) => a.dir == b.dir,
            (ParserNode::Branch(a), ParserNode::Branch(b)) => {
                a.inst == b.inst && a.rs1 == b.rs1 && a.rs2 == b.rs2 && a.name == b.name
            }
            (ParserNode::Store(a), ParserNode::Store(b)) => {
                a.inst == b.inst && a.rs1 == b.rs1 && a.rs2 == b.rs2 && a.imm == b.imm
            }
            (ParserNode::Load(a), ParserNode::Load(b)) => {
                a.inst == b.inst && a.rd == b.rd && a.rs1 == b.rs1 && a.imm == b.imm
            }
            (ParserNode::Csr(a), ParserNode::Csr(b)) => {
                a.inst == b.inst && a.rd == b.rd && a.csr == b.csr && a.rs1 == b.rs1
            }
            (ParserNode::LoadAddr(a), ParserNode::LoadAddr(b)) => {
                a.inst == b.inst && a.rd == b.rd && a.name == b.name
            }
            _ => false,
        }
    }
}
impl Eq for ParserNodeDataWrapper {}

pub trait ParserNodeData {
    fn data(&self) -> ParserNodeDataWrapper;
}

pub trait VecParserNodeData {
    fn data(&self) -> Vec<ParserNodeDataWrapper>;
}

impl ParserNodeData for ParserNode {
    fn data(&self) -> ParserNodeDataWrapper {
        ParserNodeDataWrapper(self.clone())
    }
}

impl VecParserNodeData for Vec<ParserNode> {
    fn data(&self) -> Vec<ParserNodeDataWrapper> {
        self.iter().map(ParserNodeData::data).collect()
    }
}

impl VecParserNodeData for Vec<Rc<ParserNode>> {
    fn data(&self) -> Vec<ParserNodeDataWrapper> {
        self.iter().map(|x| x.data()).collect()
    }
}
